#include "snapshot_builder.h"
#include <iostream>
#include <sstream>
#include "env-inl.h"
#include "node_external_reference.h"
#include "node_internals.h"
#include "node_main_instance.h"
#include "node_v8_platform-inl.h"

namespace node {

using v8::Context;
using v8::HandleScope;
using v8::Isolate;
using v8::Local;
using v8::Locker;
using v8::Object;
using v8::SnapshotCreator;
using v8::StartupData;

static bool log_debug = false;

template <typename T>
void WriteVector(std::stringstream* ss, const T* vec, size_t size) {
  for (size_t i = 0; i < size; i++) {
    *ss << std::to_string(vec[i]) << (i == size - 1 ? '\n' : ',');
  }
}

void WritePropInfoVector(std::stringstream* ss,
                         const std::string& name,
                         const std::vector<PropInfo>& vec) {
  *ss << "static const std::vector<PropInfo> " << name << " {";
  size_t i = 0;
  size_t size = vec.size();
  for (const auto& info : vec) {
    *ss << "{ \"" << info.name << "\", " << std::to_string(info.index) << " }"
        << (i++ == size - 1 ? "\n" : ",\n");
  }
  *ss << "};\n";
}

std::string FormatBlob(v8::StartupData* blob,
                       const std::vector<size_t>& isolate_data_indexes,
                       const EnvSerializeInfo& env_info) {
  std::stringstream ss;

  ss << R"(#include <cstddef>
#include "env.h"
#include "node_main_instance.h"
#include "v8.h"

// This file is generated by tools/snapshot. Do not edit.

namespace node {

static const char blob_data[] = {
)";
  WriteVector(&ss, blob->data, blob->raw_size);
  ss << R"(};

static const int blob_size = )"
     << blob->raw_size << R"(;
static v8::StartupData blob = { blob_data, blob_size };
)";

  ss << R"(v8::StartupData* NodeMainInstance::GetEmbeddedSnapshotBlob() {
  return &blob;
}

static const std::vector<size_t> isolate_data_indexes {
)";
  WriteVector(&ss, isolate_data_indexes.data(), isolate_data_indexes.size());
  ss << R"(};

const std::vector<size_t>* NodeMainInstance::GetIsolateDataIndexes() {
  return &isolate_data_indexes;
}

static const std::vector<size_t> async_hooks_indexes {
)";
  WriteVector(&ss,
              env_info.async_hooks_indexes.data(),
              env_info.async_hooks_indexes.size());
  ss << "};\n";

  WritePropInfoVector(
      &ss, "strong_values_indexes", env_info.strong_values_indexes);
  WritePropInfoVector(
      &ss, "strong_templates_indexes", env_info.strong_templates_indexes);
  WritePropInfoVector(
      &ss, "aliased_buffer_indexes", env_info.aliased_buffer_indexes);
  ss << R"(
static const EnvSerializeInfo env_info {
  std::move(async_hooks_indexes),
  std::move(strong_values_indexes),
  std::move(strong_templates_indexes),
  std::move(aliased_buffer_indexes)
};

const EnvSerializeInfo* NodeMainInstance::GetEnvSerializeInfo() {
  return &env_info;
}

}  // namespace node
)";

  return ss.str();
}

static v8::StartupData SerializeNodeContextInternalFields(Local<Object> holder,
                                                          int index,
                                                          void* env) {
  void* ptr = holder->GetAlignedPointerFromInternalField(index);
  if (log_debug) {
    std::cout << "Serializing Object with index " << index << " at " << ptr
              << " with Environment at " << env << "\n";
  }
  if (ptr == env) {
    InternalFieldInfo* info =
        new InternalFieldInfo{InternalFieldType::kIsEnvironment, 0};
    // Points to nullptr
    return StartupData{reinterpret_cast<const char*>(info), sizeof(*info)};
  }
  return StartupData{reinterpret_cast<const char*>(0), 0};
}

std::string SnapshotBuilder::Generate(
    const std::vector<std::string> args,
    const std::vector<std::string> exec_args) {
  std::vector<intptr_t> external_references =
      NodeMainInstance::CollectExternalReferences();
  Isolate* isolate = Isolate::Allocate();
  per_process::v8_platform.Platform()->RegisterIsolate(isolate,
                                                       uv_default_loop());
  std::unique_ptr<NodeMainInstance> main_instance;
  std::string result;

  {
    char env_buf[32];
    size_t env_size = sizeof(env_buf);
    int ret = uv_os_getenv("NODE_DEBUG_NATIVE", env_buf, &env_size);
    if (ret == 0 && strcmp(env_buf, "mksnapshot") == 0) {
      log_debug = true;
    }
  }

  {
    std::vector<size_t> isolate_data_indexes;
    EnvSerializeInfo env_info;
    SnapshotCreator creator(isolate, external_references.data());
    Environment* env =
        reinterpret_cast<Environment*>(new uint8_t[sizeof(Environment)]);
    {
      main_instance =
          NodeMainInstance::Create(isolate,
                                   uv_default_loop(),
                                   per_process::v8_platform.Platform(),
                                   args,
                                   exec_args);
      HandleScope scope(isolate);
      creator.SetDefaultContext(Context::New(isolate));
      isolate_data_indexes = main_instance->isolate_data()->Serialize(&creator);

      Local<Context> context = NewContext(isolate);
      Context::Scope context_scope(context);

      // Do the actual instantiation.
      new (env) Environment(
          main_instance->isolate_data(),
          context,
          args,
          exec_args,
          nullptr,
          static_cast<Environment::Flags>(Environment::kIsMainThread |
                                          Environment::kOwnsProcessState |
                                          Environment::kOwnsInspector));
      env->BootstrapInternalLoaders().ToLocalChecked();
      if (log_debug) {
        env->PrintAllBuffers();
        env->PrintAllBaseObjects();
      }
      env_info = env->Serialize(&creator);
      size_t index = creator.AddContext(
          context, {SerializeNodeContextInternalFields, env});
      CHECK_EQ(index, NodeMainInstance::kNodeContextIndex);
      env->RunCleanup();  // will be necessary when we initiliaze libuv
    }

    // Must be out of HandleScope
    StartupData blob =
        creator.CreateBlob(SnapshotCreator::FunctionCodeHandling::kClear);
    CHECK(blob.CanBeRehashed());
    // Must be done while the snapshot creator isolate is entered i.e. the
    // creator is still alive.
    // delete env;
    main_instance->Dispose();

    result = FormatBlob(&blob, isolate_data_indexes, env_info);
    delete[] blob.data;
  }

  per_process::v8_platform.Platform()->UnregisterIsolate(isolate);
  return result;
}
}  // namespace node
