#include "snapshot_builder.h"
#include <iostream>
#include <sstream>
#include "node_internals.h"
#include "node_main_instance.h"
#include "node_v8_platform-inl.h"
#include "snapshot_support-inl.h"

namespace node {

using v8::Context;
using v8::HandleScope;
using v8::Isolate;
using v8::SnapshotCreator;
using v8::StartupData;

template <typename T>
void WriteVector(std::stringstream* ss, const T* vec, size_t size) {
  for (size_t i = 0; i < size; i++) {
    *ss << std::to_string(vec[i]) << (i == size - 1 ? '\n' : ',');
  }
}

std::string FormatBlob(v8::StartupData* blob,
                       SnapshotCreateData* snapshot_data) {
  std::stringstream ss;

  ss << R"(#include <cstddef>
#include "node_main_instance.h"
#include "env.h"
#include "snapshot_support-inl.h"

// This file is generated by tools/snapshot. Do not edit.

namespace node {

static const char blob_data[] = {
)";
  WriteVector(&ss, blob->data, blob->raw_size);
  ss << R"(};

static const int blob_size = )"
     << blob->raw_size << R"(;
static v8::StartupData blob = { blob_data, blob_size };
)";

  ss << R"(v8::StartupData* NodeMainInstance::GetEmbeddedSnapshotBlob() {
  return &blob;
}

static SnapshotReadData snapshot_data {
  {
)";
  std::vector<uint8_t> raw_data = snapshot_data->release_storage();
  WriteVector(&ss, raw_data.data(), raw_data.size());
  ss << R"(
  }
};

SnapshotReadData* NodeMainInstance::GetSnapshotData() {
  return &snapshot_data;
}
}  // namespace node
)";

  return ss.str();
}

std::string SnapshotBuilder::Generate(
    const std::vector<std::string> args,
    const std::vector<std::string> exec_args) {
  Isolate* isolate = Isolate::Allocate();
  per_process::v8_platform.Platform()->RegisterIsolate(isolate,
                                                       uv_default_loop());
  std::unique_ptr<NodeMainInstance> main_instance;
  std::string result;
  int exit_code = 0;

  HeapExternalReferences heap_external_references =
      AllocateExternalRerefences();

  std::vector<intptr_t> external_references = ExternalReferences::get_list();
  external_references.insert(
      external_references.end(),
      heap_external_references.references.begin(),
      heap_external_references.references.end());
  external_references.push_back(ExternalReferences::kEnd);

  {
    SnapshotCreator creator(isolate, external_references.data());
    SnapshotCreateData snapshot_data(&creator);
    DeleteFnPtr<Environment, FreeEnvironment> env;
    {
      main_instance =
          NodeMainInstance::Create(isolate,
                                   uv_default_loop(),
                                   per_process::v8_platform.Platform(),
                                   args,
                                   exec_args,
                                   std::move(
                                       heap_external_references.allocations));
      HandleScope scope(isolate);
      creator.SetDefaultContext(Context::New(isolate));

      env = main_instance->CreateMainEnvironment(&exit_code);
      env->isolate_data()->Serialize(&snapshot_data);
      env->Serialize(&snapshot_data);
      snapshot_data.PrintErrorsAndAbortIfAny();
      size_t index = creator.AddContext(env->context(),
          { BaseObject::SerializeInternalFields, &snapshot_data });
      CHECK_EQ(index, NodeMainInstance::kNodeContextIndex);
      CHECK_EQ(exit_code, 0);
    }

    // Must be out of HandleScope
    StartupData blob =
        creator.CreateBlob(SnapshotCreator::FunctionCodeHandling::kClear);
    snapshot_data.PrintErrorsAndAbortIfAny();
    CHECK(blob.CanBeRehashed());
    // Must be done while the snapshot creator isolate is entered i.e. the
    // creator is still alive.
    env.reset();
    main_instance->Dispose();
    result = FormatBlob(&blob, &snapshot_data);
    delete[] blob.data;
  }

  per_process::v8_platform.Platform()->UnregisterIsolate(isolate);
  return result;
}
}  // namespace node
